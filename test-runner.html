<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Night Mode MindMap - TDD í…ŒìŠ¤íŠ¸</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .test-container {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 350px;
            max-height: 80vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 15px;
            z-index: 2000;
            overflow-y: auto;
        }
        .test-result {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-pass {
            background: #1a4d1a;
            color: #4CAF50;
            border: 1px solid #2d5a2d;
        }
        .test-fail {
            background: #4d1a1a;
            color: #f44336;
            border: 1px solid #5a2d2d;
        }
        .test-run-btn {
            width: 100%;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .test-run-btn:hover {
            background: var(--node-selected);
        }
        .test-summary {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div id="app" class="night-theme">
        <div class="toolbar">
            <button id="addCircle" class="tool-btn" title="ì›í˜• ë…¸ë“œ ì¶”ê°€">â—‹</button>
            <button id="addRect" class="tool-btn" title="ì‚¬ê°í˜• ë…¸ë“œ ì¶”ê°€">â–¡</button>
            <button id="connectMode" class="tool-btn" title="ì—°ê²° ëª¨ë“œ">âŸ·</button>
            <button id="lineStyle" class="tool-btn" title="ì„  ìŠ¤íƒ€ì¼: ì‹¤ì„ " data-style="solid">
                <svg width="20" height="4" viewBox="0 0 20 4">
                    <line x1="0" y1="2" x2="20" y2="2" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
            <button id="clear" class="tool-btn" title="ëª¨ë‘ ì§€ìš°ê¸°">Ã—</button>
        </div>
        <svg id="canvas" width="100%" height="100%">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#666666"/>
                </marker>
            </defs>
        </svg>
    </div>

    <!-- í…ŒìŠ¤íŠ¸ íŒ¨ë„ -->
    <div class="test-container">
        <button class="test-run-btn" onclick="runAllTests()">ğŸ§ª ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰</button>
        <div id="testSummary" class="test-summary">í…ŒìŠ¤íŠ¸ ì¤€ë¹„ë¨</div>
        <div id="testResults"></div>
    </div>

    <script src="mindmap.js"></script>
    <script>
        let testResults = [];
        let mindMap;

        // í…ŒìŠ¤íŠ¸ í—¬í¼ í•¨ìˆ˜ë“¤
        function describe(name, fn) {
            console.group(`ğŸ“‹ ${name}`);
            try {
                fn();
                console.log(`âœ… ${name} ì™„ë£Œ`);
            } catch (error) {
                console.error(`âŒ ${name} ì‹¤íŒ¨:`, error);
            }
            console.groupEnd();
        }

        function it(name, fn) {
            try {
                fn();
                console.log(`  âœ… ${name}`);
                addTestResult(name, true);
            } catch (error) {
                console.error(`  âŒ ${name}:`, error.message);
                addTestResult(name, false, error.message);
                throw error;
            }
        }

        function expect(actual) {
            return {
                toBe: (expected) => {
                    if (actual !== expected) {
                        throw new Error(`Expected ${expected}, got ${actual}`);
                    }
                },
                toBeTruthy: () => {
                    if (!actual) {
                        throw new Error(`Expected truthy value, got ${actual}`);
                    }
                },
                toEqual: (expected) => {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                    }
                },
                toBeLessThan: (expected) => {
                    if (actual >= expected) {
                        throw new Error(`Expected ${actual} to be less than ${expected}`);
                    }
                },
                toContain: (expected) => {
                    if (!actual.includes(expected)) {
                        throw new Error(`Expected ${actual} to contain ${expected}`);
                    }
                }
            };
        }

        function addTestResult(name, passed, error = '') {
            testResults.push({ name, passed, error });
            updateTestDisplay();
        }

        function updateTestDisplay() {
            const results = document.getElementById('testResults');
            const summary = document.getElementById('testSummary');

            const passCount = testResults.filter(r => r.passed).length;
            const totalCount = testResults.length;

            summary.textContent = `${passCount}/${totalCount} í…ŒìŠ¤íŠ¸ í†µê³¼`;

            results.innerHTML = testResults.map(result => {
                const className = result.passed ? 'test-pass' : 'test-fail';
                const icon = result.passed ? 'âœ…' : 'âŒ';
                const errorText = result.error ? `<br><small>${result.error}</small>` : '';
                return `<div class="test-result ${className}">${icon} ${result.name}${errorText}</div>`;
            }).join('');
        }

        function runAllTests() {
            testResults = [];

            // ê¸°ì¡´ ë§ˆì¸ë“œë§µ ì •ë¦¬
            if (mindMap) {
                mindMap.clearCanvas();
            }

            // ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
            mindMap = new MindMap();

            // í…ŒìŠ¤íŠ¸ ì‹¤í–‰
            describe('1. ê¸°ë³¸ ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸', () => {
                it('MindMap ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ì–´ì•¼ í•¨', () => {
                    expect(mindMap).toBeTruthy();
                    expect(mindMap.nodes).toEqual([]);
                    expect(mindMap.connections).toEqual([]);
                    expect(mindMap.connectMode).toBe(false);
                    expect(mindMap.lineStyle).toBe('solid');
                });

                it('ë‚˜ì´íŠ¸ ëª¨ë“œ í…Œë§ˆê°€ ì ìš©ë˜ì–´ì•¼ í•¨', () => {
                    const container = document.getElementById('app');
                    expect(container.classList.contains('night-theme')).toBe(true);
                });

                it('ëª¨ë“  í•„ìˆ˜ ë²„íŠ¼ì´ ì¡´ì¬í•´ì•¼ í•¨', () => {
                    expect(document.getElementById('addCircle')).toBeTruthy();
                    expect(document.getElementById('addRect')).toBeTruthy();
                    expect(document.getElementById('connectMode')).toBeTruthy();
                    expect(document.getElementById('lineStyle')).toBeTruthy();
                    expect(document.getElementById('clear')).toBeTruthy();
                });
            });

            describe('2. ë…¸ë“œ ìƒì„± í…ŒìŠ¤íŠ¸', () => {
                it('ì›í˜• ë…¸ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const initialCount = mindMap.getNodeCount();
                    document.getElementById('addCircle').click();

                    expect(mindMap.getNodeCount()).toBe(initialCount + 1);
                    expect(mindMap.nodes[mindMap.nodes.length - 1].type).toBe('circle');
                });

                it('ì‚¬ê°í˜• ë…¸ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const initialCount = mindMap.getNodeCount();
                    document.getElementById('addRect').click();

                    expect(mindMap.getNodeCount()).toBe(initialCount + 1);
                    expect(mindMap.nodes[mindMap.nodes.length - 1].type).toBe('rect');
                });

                it('ë…¸ë“œê°€ ì˜¬ë°”ë¥¸ DOM êµ¬ì¡°ë¥¼ ê°€ì ¸ì•¼ í•¨', () => {
                    document.getElementById('addCircle').click();
                    const node = mindMap.nodes[mindMap.nodes.length - 1];

                    expect(node.element).toBeTruthy();
                    expect(node.shape).toBeTruthy();
                    expect(node.textElement).toBeTruthy();
                });

                it('ì—°ì† ìƒì„±ëœ ë…¸ë“œë“¤ì´ ê²¹ì¹˜ì§€ ì•Šì•„ì•¼ í•¨', () => {
                    mindMap.clearCanvas();

                    // ì—¬ëŸ¬ ë…¸ë“œ ìƒì„±
                    for (let i = 0; i < 5; i++) {
                        document.getElementById('addCircle').click();
                    }

                    const nodes = mindMap.nodes;
                    expect(nodes.length).toBe(5);

                    // ë…¸ë“œ ê°„ ê±°ë¦¬ ì²´í¬ (ìµœì†Œ 80px ê°„ê²©)
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const dx = nodes[i].x - nodes[j].x;
                            const dy = nodes[i].y - nodes[j].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            expect(distance).toBeLessThan(200); // ë„ˆë¬´ ë©€ì§€ ì•Šê³ 
                            // ìµœì†Œ ê°„ê²©ì€ ê·¸ë¦¬ë“œ ì‹œìŠ¤í…œìœ¼ë¡œ ë³´ì¥ë¨
                        }
                    }
                });
            });

            describe('3. ì—°ê²° ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸', () => {
                it('ì—°ê²° ëª¨ë“œë¥¼ í† ê¸€í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const connectBtn = document.getElementById('connectMode');

                    expect(mindMap.connectMode).toBe(false);
                    connectBtn.click();
                    expect(mindMap.connectMode).toBe(true);

                    connectBtn.click();
                    expect(mindMap.connectMode).toBe(false);
                });

                it('ì„  ìŠ¤íƒ€ì¼ì„ ë³€ê²½í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const lineStyleBtn = document.getElementById('lineStyle');

                    expect(mindMap.lineStyle).toBe('solid');
                    lineStyleBtn.click();
                    expect(mindMap.lineStyle).toBe('dashed');

                    lineStyleBtn.click();
                    expect(mindMap.lineStyle).toBe('solid');
                });

                it('ì„  ìŠ¤íƒ€ì¼ ë²„íŠ¼ UIê°€ ì˜¬ë°”ë¥´ê²Œ ì—…ë°ì´íŠ¸ë˜ì–´ì•¼ í•¨', () => {
                    const lineStyleBtn = document.getElementById('lineStyle');
                    const svgLine = lineStyleBtn.querySelector('svg line');

                    // ì´ˆê¸° ìƒíƒœ (ì‹¤ì„ )
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('solid');
                    expect(lineStyleBtn.getAttribute('title')).toContain('ì‹¤ì„ ');
                    expect(svgLine.hasAttribute('stroke-dasharray')).toBe(false);

                    // ì ì„ ìœ¼ë¡œ ë³€ê²½
                    lineStyleBtn.click();
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('dashed');
                    expect(lineStyleBtn.getAttribute('title')).toContain('ì ì„ ');
                    expect(svgLine.getAttribute('stroke-dasharray')).toBe('4,2');

                    // ë‹¤ì‹œ ì‹¤ì„ ìœ¼ë¡œ ë³€ê²½
                    lineStyleBtn.click();
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('solid');
                    expect(lineStyleBtn.getAttribute('title')).toContain('ì‹¤ì„ ');
                    expect(svgLine.hasAttribute('stroke-dasharray')).toBe(false);
                });

                it('ì—°ê²°ì„ ìƒì„±í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    // ë…¸ë“œ 2ê°œ ìƒì„±
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    const node1 = mindMap.nodes[mindMap.nodes.length - 2];
                    const node2 = mindMap.nodes[mindMap.nodes.length - 1];

                    // ì—°ê²° ìƒì„±
                    const connection = mindMap.createConnection(node1, node2);

                    expect(connection).toBeTruthy();
                    expect(mindMap.getConnectionCount()).toBe(1);
                });
            });

            describe('4. ë‚˜ì´íŠ¸ ëª¨ë“œ ìƒ‰ìƒ í…ŒìŠ¤íŠ¸', () => {
                it('CSS ë³€ìˆ˜ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ì•¼ í•¨', () => {
                    const root = document.documentElement;
                    const bgPrimary = getComputedStyle(root).getPropertyValue('--bg-primary').trim();

                    expect(bgPrimary).toBe('#0a0a0a');
                });

                it('ë…¸ë“œê°€ ë‚˜ì´íŠ¸ ëª¨ë“œ ìƒ‰ìƒì„ ì‚¬ìš©í•´ì•¼ í•¨', () => {
                    document.getElementById('addCircle').click();
                    const node = mindMap.nodes[mindMap.nodes.length - 1];

                    const computedStyle = window.getComputedStyle(node.shape);
                    expect(computedStyle.fill).toContain('rgb');
                });
            });

            describe('5. ì„±ëŠ¥ ìµœì í™” í…ŒìŠ¤íŠ¸', () => {
                it('ë§ì€ ë…¸ë“œ ìƒì„± ì‹œ ì„±ëŠ¥ì´ ìœ ì§€ë˜ì–´ì•¼ í•¨', () => {
                    const startTime = performance.now();

                    // 50ê°œ ë…¸ë“œ ìƒì„± (ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œëŠ” ì ê²Œ)
                    for (let i = 0; i < 50; i++) {
                        mindMap.addNode('circle', Math.random() * 600 + 100, Math.random() * 400 + 100);
                    }

                    const endTime = performance.now();
                    const duration = endTime - startTime;

                    expect(mindMap.getNodeCount()).toBe(50);
                    expect(duration).toBeLessThan(1000); // 1ì´ˆ ì´ë‚´
                });

                it('ì—°ê²°ì„  ì—…ë°ì´íŠ¸ê°€ íš¨ìœ¨ì ì´ì–´ì•¼ í•¨', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('circle', 200, 200);
                    mindMap.createConnection(mindMap.nodes[0], mindMap.nodes[1]);

                    const startTime = performance.now();

                    // ë…¸ë“œ ì´ë™ ì‹œë®¬ë ˆì´ì…˜
                    mindMap.moveNode(mindMap.nodes[0], 300, 300);

                    const endTime = performance.now();
                    const duration = endTime - startTime;

                    expect(duration).toBeLessThan(50); // 50ms ì´ë‚´
                });
            });

            describe('6. ê°œë³„ ë…¸ë“œ ì‚­ì œ í…ŒìŠ¤íŠ¸', () => {
                it('ìš°í´ë¦­ìœ¼ë¡œ ê°œë³„ ë…¸ë“œë¥¼ ì‚­ì œí•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    expect(mindMap.getNodeCount()).toBe(2);

                    const node = mindMap.nodes[0];
                    mindMap.deleteNode(node);

                    expect(mindMap.getNodeCount()).toBe(1);
                    expect(mindMap.nodes.includes(node)).toBe(false);
                });

                it('Delete í‚¤ë¡œ ì„ íƒëœ ë…¸ë“œë“¤ì„ ì‚­ì œí•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    // ë…¸ë“œ ì„ íƒ
                    mindMap.selectNode(mindMap.nodes[0]);

                    // Delete í‚¤ ì‹œë®¬ë ˆì´ì…˜
                    const deleteEvent = new KeyboardEvent('keydown', { key: 'Delete' });
                    document.dispatchEvent(deleteEvent);

                    expect(mindMap.getNodeCount()).toBe(1);
                });
            });

            describe('7. ë‹¤ì¤‘ ì„ íƒ í…ŒìŠ¤íŠ¸', () => {
                beforeEach(() => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.addNode('circle', 300, 300);
                });

                it('Ctrl+í´ë¦­ìœ¼ë¡œ ë‹¤ì¤‘ ì„ íƒí•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    // ì²« ë²ˆì§¸ ë…¸ë“œ ì„ íƒ
                    mindMap.selectNode(node1);
                    expect(mindMap.selectedNodes.length).toBe(1);

                    // Ctrl+í´ë¦­ìœ¼ë¡œ ë‘ ë²ˆì§¸ ë…¸ë“œ ì¶”ê°€ ì„ íƒ
                    mindMap.toggleNodeSelection(node2);
                    expect(mindMap.selectedNodes.length).toBe(2);
                    expect(mindMap.selectedNodes.includes(node1)).toBe(true);
                    expect(mindMap.selectedNodes.includes(node2)).toBe(true);
                });

                it('ë‹¤ì¤‘ ì„ íƒëœ ë…¸ë“œë“¤ì´ ì˜¬ë°”ë¥¸ CSS í´ë˜ìŠ¤ë¥¼ ê°€ì ¸ì•¼ í•¨', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    mindMap.selectNode(node1);
                    mindMap.toggleNodeSelection(node2);

                    expect(node1.element.classList.contains('multi-selected')).toBe(true);
                    expect(node2.element.classList.contains('multi-selected')).toBe(true);
                });

                it('ë‹¤ì¤‘ ì„ íƒëœ ë…¸ë“œë“¤ì„ í•¨ê»˜ ì´ë™í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    const initialX1 = node1.x;
                    const initialX2 = node2.x;

                    mindMap.selectNode(node1);
                    mindMap.toggleNodeSelection(node2);

                    // í•¨ê»˜ ì´ë™
                    mindMap.moveSelectedNodes(50, 30);

                    expect(node1.x).toBe(initialX1 + 50);
                    expect(node2.x).toBe(initialX2 + 50);
                    expect(node1.y).toBe(100 + 30);
                    expect(node2.y).toBe(200 + 30);
                });
            });

            describe('8. ë“œë˜ê·¸ ì„ íƒ í…ŒìŠ¤íŠ¸', () => {
                beforeEach(() => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.addNode('circle', 150, 150);
                });

                it('ë“œë˜ê·¸ ì„ íƒì„ ì‹œì‘í•  ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    const startEvent = {
                        target: mindMap.canvas,
                        clientX: 50,
                        clientY: 50
                    };

                    mindMap.startDragSelection(startEvent);

                    expect(mindMap.isSelecting).toBe(true);
                    expect(mindMap.selectionBox).toBeTruthy();
                });

                it('ì„ íƒ ë°•ìŠ¤ ë‚´ì˜ ë…¸ë“œë“¤ì„ ì˜¬ë°”ë¥´ê²Œ ì‹ë³„í•´ì•¼ í•¨', () => {
                    const node1 = mindMap.nodes[0]; // (100, 100)
                    const node2 = mindMap.nodes[1]; // (200, 200)

                    // ë…¸ë“œ1ë§Œ í¬í•¨í•˜ëŠ” ì„ íƒ ë°•ìŠ¤ í…ŒìŠ¤íŠ¸
                    const inSelection1 = mindMap.isNodeInSelection(node1, 50, 50, 100, 100);
                    const inSelection2 = mindMap.isNodeInSelection(node2, 50, 50, 100, 100);

                    expect(inSelection1).toBe(true);
                    expect(inSelection2).toBe(false);
                });

                it('ë“œë˜ê·¸ ì„ íƒ ì™„ë£Œ ì‹œ ë…¸ë“œë“¤ì´ ì„ íƒë˜ì–´ì•¼ í•¨', () => {
                    // ì„ íƒ ë°•ìŠ¤ì— ë…¸ë“œë“¤ì„ í‘œì‹œ
                    mindMap.nodes.forEach(node => {
                        node.element.classList.add('selecting');
                    });

                    mindMap.endDragSelection();

                    expect(mindMap.selectedNodes.length).toBe(3);
                    expect(mindMap.isSelecting).toBe(false);
                    expect(mindMap.selectionBox).toBe(null);
                });
            });

            describe('9. ìº”ë²„ìŠ¤ ì§€ìš°ê¸° í…ŒìŠ¤íŠ¸', () => {
                it('ëª¨ë“  ë…¸ë“œì™€ ì—°ê²°ì„ ì§€ìš¸ ìˆ˜ ìˆì–´ì•¼ í•¨', () => {
                    // ë…¸ë“œì™€ ì—°ê²° ìƒì„±
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.createConnection(mindMap.nodes[0], mindMap.nodes[1]);

                    expect(mindMap.getNodeCount()).toBe(2);
                    expect(mindMap.getConnectionCount()).toBe(1);

                    // ì§€ìš°ê¸°
                    document.getElementById('clear').click();

                    expect(mindMap.getNodeCount()).toBe(0);
                    expect(mindMap.getConnectionCount()).toBe(0);
                });
            });

            console.log(`\\nì´ ${testResults.length}ê°œ í…ŒìŠ¤íŠ¸ ì¤‘ ${testResults.filter(r => r.passed).length}ê°œ í†µê³¼`);
        }

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            mindMap = new MindMap();
            console.log('ğŸŒ™ Night Mode Minimal MindMap í…ŒìŠ¤íŠ¸ í™˜ê²½ ì¤€ë¹„ ì™„ë£Œ');
        });
    </script>
</body>
</html>