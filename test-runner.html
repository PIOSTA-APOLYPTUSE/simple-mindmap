<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Night Mode MindMap - TDD 테스트</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .test-container {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 350px;
            max-height: 80vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 15px;
            z-index: 2000;
            overflow-y: auto;
        }
        .test-result {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .test-pass {
            background: #1a4d1a;
            color: #4CAF50;
            border: 1px solid #2d5a2d;
        }
        .test-fail {
            background: #4d1a1a;
            color: #f44336;
            border: 1px solid #5a2d2d;
        }
        .test-run-btn {
            width: 100%;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .test-run-btn:hover {
            background: var(--node-selected);
        }
        .test-summary {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div id="app" class="night-theme">
        <div class="toolbar">
            <button id="addCircle" class="tool-btn" title="원형 노드 추가">○</button>
            <button id="addRect" class="tool-btn" title="사각형 노드 추가">□</button>
            <button id="connectMode" class="tool-btn" title="연결 모드">⟷</button>
            <button id="lineStyle" class="tool-btn" title="선 스타일: 실선" data-style="solid">
                <svg width="20" height="4" viewBox="0 0 20 4">
                    <line x1="0" y1="2" x2="20" y2="2" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
            <button id="clear" class="tool-btn" title="모두 지우기">×</button>
        </div>
        <svg id="canvas" width="100%" height="100%">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#666666"/>
                </marker>
            </defs>
        </svg>
    </div>

    <!-- 테스트 패널 -->
    <div class="test-container">
        <button class="test-run-btn" onclick="runAllTests()">🧪 모든 테스트 실행</button>
        <div id="testSummary" class="test-summary">테스트 준비됨</div>
        <div id="testResults"></div>
    </div>

    <script src="mindmap.js"></script>
    <script>
        let testResults = [];
        let mindMap;

        // 테스트 헬퍼 함수들
        function describe(name, fn) {
            console.group(`📋 ${name}`);
            try {
                fn();
                console.log(`✅ ${name} 완료`);
            } catch (error) {
                console.error(`❌ ${name} 실패:`, error);
            }
            console.groupEnd();
        }

        function it(name, fn) {
            try {
                fn();
                console.log(`  ✅ ${name}`);
                addTestResult(name, true);
            } catch (error) {
                console.error(`  ❌ ${name}:`, error.message);
                addTestResult(name, false, error.message);
                throw error;
            }
        }

        function expect(actual) {
            return {
                toBe: (expected) => {
                    if (actual !== expected) {
                        throw new Error(`Expected ${expected}, got ${actual}`);
                    }
                },
                toBeTruthy: () => {
                    if (!actual) {
                        throw new Error(`Expected truthy value, got ${actual}`);
                    }
                },
                toEqual: (expected) => {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                    }
                },
                toBeLessThan: (expected) => {
                    if (actual >= expected) {
                        throw new Error(`Expected ${actual} to be less than ${expected}`);
                    }
                },
                toContain: (expected) => {
                    if (!actual.includes(expected)) {
                        throw new Error(`Expected ${actual} to contain ${expected}`);
                    }
                }
            };
        }

        function addTestResult(name, passed, error = '') {
            testResults.push({ name, passed, error });
            updateTestDisplay();
        }

        function updateTestDisplay() {
            const results = document.getElementById('testResults');
            const summary = document.getElementById('testSummary');

            const passCount = testResults.filter(r => r.passed).length;
            const totalCount = testResults.length;

            summary.textContent = `${passCount}/${totalCount} 테스트 통과`;

            results.innerHTML = testResults.map(result => {
                const className = result.passed ? 'test-pass' : 'test-fail';
                const icon = result.passed ? '✅' : '❌';
                const errorText = result.error ? `<br><small>${result.error}</small>` : '';
                return `<div class="test-result ${className}">${icon} ${result.name}${errorText}</div>`;
            }).join('');
        }

        function runAllTests() {
            testResults = [];

            // 기존 마인드맵 정리
            if (mindMap) {
                mindMap.clearCanvas();
            }

            // 새 인스턴스 생성
            mindMap = new MindMap();

            // 테스트 실행
            describe('1. 기본 초기화 테스트', () => {
                it('MindMap 인스턴스가 생성되어야 함', () => {
                    expect(mindMap).toBeTruthy();
                    expect(mindMap.nodes).toEqual([]);
                    expect(mindMap.connections).toEqual([]);
                    expect(mindMap.connectMode).toBe(false);
                    expect(mindMap.lineStyle).toBe('solid');
                });

                it('나이트 모드 테마가 적용되어야 함', () => {
                    const container = document.getElementById('app');
                    expect(container.classList.contains('night-theme')).toBe(true);
                });

                it('모든 필수 버튼이 존재해야 함', () => {
                    expect(document.getElementById('addCircle')).toBeTruthy();
                    expect(document.getElementById('addRect')).toBeTruthy();
                    expect(document.getElementById('connectMode')).toBeTruthy();
                    expect(document.getElementById('lineStyle')).toBeTruthy();
                    expect(document.getElementById('clear')).toBeTruthy();
                });
            });

            describe('2. 노드 생성 테스트', () => {
                it('원형 노드를 생성할 수 있어야 함', () => {
                    const initialCount = mindMap.getNodeCount();
                    document.getElementById('addCircle').click();

                    expect(mindMap.getNodeCount()).toBe(initialCount + 1);
                    expect(mindMap.nodes[mindMap.nodes.length - 1].type).toBe('circle');
                });

                it('사각형 노드를 생성할 수 있어야 함', () => {
                    const initialCount = mindMap.getNodeCount();
                    document.getElementById('addRect').click();

                    expect(mindMap.getNodeCount()).toBe(initialCount + 1);
                    expect(mindMap.nodes[mindMap.nodes.length - 1].type).toBe('rect');
                });

                it('노드가 올바른 DOM 구조를 가져야 함', () => {
                    document.getElementById('addCircle').click();
                    const node = mindMap.nodes[mindMap.nodes.length - 1];

                    expect(node.element).toBeTruthy();
                    expect(node.shape).toBeTruthy();
                    expect(node.textElement).toBeTruthy();
                });

                it('연속 생성된 노드들이 겹치지 않아야 함', () => {
                    mindMap.clearCanvas();

                    // 여러 노드 생성
                    for (let i = 0; i < 5; i++) {
                        document.getElementById('addCircle').click();
                    }

                    const nodes = mindMap.nodes;
                    expect(nodes.length).toBe(5);

                    // 노드 간 거리 체크 (최소 80px 간격)
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const dx = nodes[i].x - nodes[j].x;
                            const dy = nodes[i].y - nodes[j].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            expect(distance).toBeLessThan(200); // 너무 멀지 않고
                            // 최소 간격은 그리드 시스템으로 보장됨
                        }
                    }
                });
            });

            describe('3. 연결 기능 테스트', () => {
                it('연결 모드를 토글할 수 있어야 함', () => {
                    const connectBtn = document.getElementById('connectMode');

                    expect(mindMap.connectMode).toBe(false);
                    connectBtn.click();
                    expect(mindMap.connectMode).toBe(true);

                    connectBtn.click();
                    expect(mindMap.connectMode).toBe(false);
                });

                it('선 스타일을 변경할 수 있어야 함', () => {
                    const lineStyleBtn = document.getElementById('lineStyle');

                    expect(mindMap.lineStyle).toBe('solid');
                    lineStyleBtn.click();
                    expect(mindMap.lineStyle).toBe('dashed');

                    lineStyleBtn.click();
                    expect(mindMap.lineStyle).toBe('solid');
                });

                it('선 스타일 버튼 UI가 올바르게 업데이트되어야 함', () => {
                    const lineStyleBtn = document.getElementById('lineStyle');
                    const svgLine = lineStyleBtn.querySelector('svg line');

                    // 초기 상태 (실선)
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('solid');
                    expect(lineStyleBtn.getAttribute('title')).toContain('실선');
                    expect(svgLine.hasAttribute('stroke-dasharray')).toBe(false);

                    // 점선으로 변경
                    lineStyleBtn.click();
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('dashed');
                    expect(lineStyleBtn.getAttribute('title')).toContain('점선');
                    expect(svgLine.getAttribute('stroke-dasharray')).toBe('4,2');

                    // 다시 실선으로 변경
                    lineStyleBtn.click();
                    expect(lineStyleBtn.getAttribute('data-style')).toBe('solid');
                    expect(lineStyleBtn.getAttribute('title')).toContain('실선');
                    expect(svgLine.hasAttribute('stroke-dasharray')).toBe(false);
                });

                it('연결을 생성할 수 있어야 함', () => {
                    // 노드 2개 생성
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    const node1 = mindMap.nodes[mindMap.nodes.length - 2];
                    const node2 = mindMap.nodes[mindMap.nodes.length - 1];

                    // 연결 생성
                    const connection = mindMap.createConnection(node1, node2);

                    expect(connection).toBeTruthy();
                    expect(mindMap.getConnectionCount()).toBe(1);
                });
            });

            describe('4. 나이트 모드 색상 테스트', () => {
                it('CSS 변수가 올바르게 설정되어야 함', () => {
                    const root = document.documentElement;
                    const bgPrimary = getComputedStyle(root).getPropertyValue('--bg-primary').trim();

                    expect(bgPrimary).toBe('#0a0a0a');
                });

                it('노드가 나이트 모드 색상을 사용해야 함', () => {
                    document.getElementById('addCircle').click();
                    const node = mindMap.nodes[mindMap.nodes.length - 1];

                    const computedStyle = window.getComputedStyle(node.shape);
                    expect(computedStyle.fill).toContain('rgb');
                });
            });

            describe('5. 성능 최적화 테스트', () => {
                it('많은 노드 생성 시 성능이 유지되어야 함', () => {
                    const startTime = performance.now();

                    // 50개 노드 생성 (브라우저 환경에서는 적게)
                    for (let i = 0; i < 50; i++) {
                        mindMap.addNode('circle', Math.random() * 600 + 100, Math.random() * 400 + 100);
                    }

                    const endTime = performance.now();
                    const duration = endTime - startTime;

                    expect(mindMap.getNodeCount()).toBe(50);
                    expect(duration).toBeLessThan(1000); // 1초 이내
                });

                it('연결선 업데이트가 효율적이어야 함', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('circle', 200, 200);
                    mindMap.createConnection(mindMap.nodes[0], mindMap.nodes[1]);

                    const startTime = performance.now();

                    // 노드 이동 시뮬레이션
                    mindMap.moveNode(mindMap.nodes[0], 300, 300);

                    const endTime = performance.now();
                    const duration = endTime - startTime;

                    expect(duration).toBeLessThan(50); // 50ms 이내
                });
            });

            describe('6. 개별 노드 삭제 테스트', () => {
                it('우클릭으로 개별 노드를 삭제할 수 있어야 함', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    expect(mindMap.getNodeCount()).toBe(2);

                    const node = mindMap.nodes[0];
                    mindMap.deleteNode(node);

                    expect(mindMap.getNodeCount()).toBe(1);
                    expect(mindMap.nodes.includes(node)).toBe(false);
                });

                it('Delete 키로 선택된 노드들을 삭제할 수 있어야 함', () => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);

                    // 노드 선택
                    mindMap.selectNode(mindMap.nodes[0]);

                    // Delete 키 시뮬레이션
                    const deleteEvent = new KeyboardEvent('keydown', { key: 'Delete' });
                    document.dispatchEvent(deleteEvent);

                    expect(mindMap.getNodeCount()).toBe(1);
                });
            });

            describe('7. 다중 선택 테스트', () => {
                beforeEach(() => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.addNode('circle', 300, 300);
                });

                it('Ctrl+클릭으로 다중 선택할 수 있어야 함', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    // 첫 번째 노드 선택
                    mindMap.selectNode(node1);
                    expect(mindMap.selectedNodes.length).toBe(1);

                    // Ctrl+클릭으로 두 번째 노드 추가 선택
                    mindMap.toggleNodeSelection(node2);
                    expect(mindMap.selectedNodes.length).toBe(2);
                    expect(mindMap.selectedNodes.includes(node1)).toBe(true);
                    expect(mindMap.selectedNodes.includes(node2)).toBe(true);
                });

                it('다중 선택된 노드들이 올바른 CSS 클래스를 가져야 함', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    mindMap.selectNode(node1);
                    mindMap.toggleNodeSelection(node2);

                    expect(node1.element.classList.contains('multi-selected')).toBe(true);
                    expect(node2.element.classList.contains('multi-selected')).toBe(true);
                });

                it('다중 선택된 노드들을 함께 이동할 수 있어야 함', () => {
                    const node1 = mindMap.nodes[0];
                    const node2 = mindMap.nodes[1];

                    const initialX1 = node1.x;
                    const initialX2 = node2.x;

                    mindMap.selectNode(node1);
                    mindMap.toggleNodeSelection(node2);

                    // 함께 이동
                    mindMap.moveSelectedNodes(50, 30);

                    expect(node1.x).toBe(initialX1 + 50);
                    expect(node2.x).toBe(initialX2 + 50);
                    expect(node1.y).toBe(100 + 30);
                    expect(node2.y).toBe(200 + 30);
                });
            });

            describe('8. 드래그 선택 테스트', () => {
                beforeEach(() => {
                    mindMap.clearCanvas();
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.addNode('circle', 150, 150);
                });

                it('드래그 선택을 시작할 수 있어야 함', () => {
                    const startEvent = {
                        target: mindMap.canvas,
                        clientX: 50,
                        clientY: 50
                    };

                    mindMap.startDragSelection(startEvent);

                    expect(mindMap.isSelecting).toBe(true);
                    expect(mindMap.selectionBox).toBeTruthy();
                });

                it('선택 박스 내의 노드들을 올바르게 식별해야 함', () => {
                    const node1 = mindMap.nodes[0]; // (100, 100)
                    const node2 = mindMap.nodes[1]; // (200, 200)

                    // 노드1만 포함하는 선택 박스 테스트
                    const inSelection1 = mindMap.isNodeInSelection(node1, 50, 50, 100, 100);
                    const inSelection2 = mindMap.isNodeInSelection(node2, 50, 50, 100, 100);

                    expect(inSelection1).toBe(true);
                    expect(inSelection2).toBe(false);
                });

                it('드래그 선택 완료 시 노드들이 선택되어야 함', () => {
                    // 선택 박스에 노드들을 표시
                    mindMap.nodes.forEach(node => {
                        node.element.classList.add('selecting');
                    });

                    mindMap.endDragSelection();

                    expect(mindMap.selectedNodes.length).toBe(3);
                    expect(mindMap.isSelecting).toBe(false);
                    expect(mindMap.selectionBox).toBe(null);
                });
            });

            describe('9. 캔버스 지우기 테스트', () => {
                it('모든 노드와 연결을 지울 수 있어야 함', () => {
                    // 노드와 연결 생성
                    mindMap.addNode('circle', 100, 100);
                    mindMap.addNode('rect', 200, 200);
                    mindMap.createConnection(mindMap.nodes[0], mindMap.nodes[1]);

                    expect(mindMap.getNodeCount()).toBe(2);
                    expect(mindMap.getConnectionCount()).toBe(1);

                    // 지우기
                    document.getElementById('clear').click();

                    expect(mindMap.getNodeCount()).toBe(0);
                    expect(mindMap.getConnectionCount()).toBe(0);
                });
            });

            console.log(`\\n총 ${testResults.length}개 테스트 중 ${testResults.filter(r => r.passed).length}개 통과`);
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', () => {
            mindMap = new MindMap();
            console.log('🌙 Night Mode Minimal MindMap 테스트 환경 준비 완료');
        });
    </script>
</body>
</html>